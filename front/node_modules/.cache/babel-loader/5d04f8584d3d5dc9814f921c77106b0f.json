{"ast":null,"code":"import _objectSpread from\"/home/webmaster/front/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import React from'react';import{Rect,Transformer}from'react-konva';var Rectangle=function Rectangle(_ref){var shapeProps=_ref.shapeProps,isSelected=_ref.isSelected,onSelect=_ref.onSelect,onChange=_ref.onChange;var shapeRef=React.useRef();var trRef=React.useRef();React.useEffect(function(){if(isSelected){// we need to attach transformer manually\ntrRef.current.nodes([shapeRef.current]);trRef.current.getLayer().batchDraw();}},[isSelected]);return/*#__PURE__*/React.createElement(React.Fragment,null,/*#__PURE__*/React.createElement(Rect,{onClick:onSelect,onTap:onSelect,ref:shapeRef// {...shapeProps}\n,x:shapeProps.x*2,y:shapeProps.y*2,width:shapeProps.width*2,height:shapeProps.height*2,stroke:shapeProps.type===0?\"red\":\"blue\",draggable:true,onDragEnd:function onDragEnd(e){onChange(_objectSpread({},shapeProps,{x:e.target.x()/2,y:e.target.y()/2}));},onTransformEnd:function onTransformEnd(e){// transformer is changing scale of the node\n// and NOT its width or height\n// but in the store we have only width and height\n// to match the data better we will reset scale on transform end\nvar node=shapeRef.current;var scaleX=node.scaleX();var scaleY=node.scaleY();// we will reset it back\nnode.scaleX(1);node.scaleY(1);onChange(_objectSpread({},shapeProps,{x:node.x()/2,y:node.y()/2,// set minimal value\nwidth:Math.max(5,node.width()*scaleX)>100?100:Math.max(5,node.width()*scaleX/2),height:Math.max(node.height()*scaleY)>100?100:Math.max(node.height()*scaleY/2)}));}}),isSelected&&/*#__PURE__*/React.createElement(Transformer,{ref:trRef,boundBoxFunc:function boundBoxFunc(oldBox,newBox){// limit resize\nif(newBox.width<5||newBox.height<5){return oldBox;}return newBox;}}));};export default Rectangle;","map":{"version":3,"sources":["/home/webmaster/front/src/components/Detect/Rectangle.js"],"names":["React","Rect","Transformer","Rectangle","shapeProps","isSelected","onSelect","onChange","shapeRef","useRef","trRef","useEffect","current","nodes","getLayer","batchDraw","x","y","width","height","type","e","target","node","scaleX","scaleY","Math","max","oldBox","newBox"],"mappings":"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","sourcesContent":["import React from 'react';\nimport { Rect, Transformer } from 'react-konva';\n\nconst Rectangle = ({ shapeProps, isSelected, onSelect, onChange }) => {\n  const shapeRef = React.useRef();\n  const trRef = React.useRef();\n\n  React.useEffect(() => {\n    if (isSelected) {\n      // we need to attach transformer manually\n      trRef.current.nodes([shapeRef.current]);\n      trRef.current.getLayer().batchDraw();\n    }\n  }, [isSelected]);\n\n  return (\n    <React.Fragment>\n      <Rect\n        onClick={onSelect}\n        onTap={onSelect}\n        ref={shapeRef}\n        // {...shapeProps}\n        x={shapeProps.x*2}\n        y={shapeProps.y*2}\n        width={shapeProps.width*2}\n        height={shapeProps.height*2}\n        stroke={shapeProps.type === 0 ? \"red\" : \"blue\"}\n        draggable\n        onDragEnd={(e) => {\n          onChange({\n            ...shapeProps,\n            x: e.target.x()/2,\n            y: e.target.y()/2,\n          });\n        }}\n        onTransformEnd={(e) => {\n          // transformer is changing scale of the node\n          // and NOT its width or height\n          // but in the store we have only width and height\n          // to match the data better we will reset scale on transform end\n          const node = shapeRef.current;\n          const scaleX = node.scaleX();\n          const scaleY = node.scaleY();\n\n          // we will reset it back\n          node.scaleX(1);\n          node.scaleY(1);\n          onChange({\n            ...shapeProps,\n            x: node.x()/2,\n            y: node.y()/2,\n            // set minimal value\n            width: Math.max(5, node.width() * scaleX) > 100 ? 100 : Math.max(5, node.width() * scaleX/2),\n            height: Math.max(node.height() * scaleY) > 100 ? 100 : Math.max(node.height() * scaleY/2),\n          });\n        }}\n      />\n      {isSelected && (\n        <Transformer\n          ref={trRef}\n          boundBoxFunc={(oldBox, newBox) => {\n            // limit resize\n            if (newBox.width < 5 || newBox.height < 5) {\n              return oldBox;\n            }\n            return newBox;\n          }}\n        />\n      )}\n    </React.Fragment>\n  );\n};\n\nexport default Rectangle;"]},"metadata":{},"sourceType":"module"}